import dev.baseio.security.CapillaryInstances
import dev.baseio.security.HybridRsaUtils.encrypt
import dev.baseio.security.OAEPParameterSpec
import dev.baseio.security.Padding
import dev.baseio.security.toPublicKey
import kotlin.test.Test
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

class TestCapillaryInitialization {

  @Test
  fun test() {
    val publicKey = byteArrayOf(
      48,
      -126,
      1,
      10,
      2,
      -126,
      1,
      1,
      0,
      -41,
      78,
      -36,
      72,
      24,
      105,
      19,
      -7,
      -11,
      9,
      -63,
      -73,
      3,
      -120,
      38,
      -37,
      -10,
      83,
      0,
      109,
      65,
      81,
      12,
      -73,
      123,
      27,
      -109,
      -7,
      -111,
      110,
      107,
      -32,
      -121,
      14,
      13,
      119,
      102,
      11,
      19,
      84,
      -109,
      -10,
      121,
      -54,
      44,
      -61,
      -76,
      115,
      79,
      51,
      72,
      -50,
      -49,
      8,
      63,
      28,
      94,
      -74,
      -32,
      -20,
      24,
      -96,
      66,
      -123,
      -84,
      91,
      -92,
      65,
      79,
      47,
      -101,
      -82,
      113,
      67,
      -82,
      19,
      117,
      88,
      -103,
      17,
      107,
      -103,
      23,
      22,
      -2,
      22,
      8,
      115,
      -93,
      -9,
      -14,
      117,
      99,
      -121,
      60,
      70,
      89,
      36,
      -43,
      -65,
      -94,
      -7,
      54,
      -32,
      -7,
      -92,
      78,
      -54,
      77,
      109,
      -73,
      101,
      -13,
      -99,
      -80,
      -88,
      -58,
      76,
      78,
      59,
      118,
      63,
      6,
      -38,
      -119,
      -79,
      30,
      -28,
      12,
      62,
      43,
      106,
      -106,
      3,
      89,
      -22,
      56,
      30,
      28,
      96,
      -3,
      -106,
      -40,
      -112,
      -37,
      -123,
      -93,
      -125,
      -84,
      50,
      72,
      123,
      -9,
      22,
      116,
      15,
      -25,
      -110,
      -101,
      -60,
      11,
      1,
      -115,
      -79,
      7,
      -95,
      -17,
      19,
      -67,
      -14,
      -71,
      44,
      45,
      0,
      -128,
      -115,
      86,
      -17,
      44,
      -19,
      -96,
      23,
      -25,
      18,
      -37,
      -34,
      -62,
      -26,
      -6,
      -116,
      -28,
      43,
      -88,
      -100,
      -104,
      -47,
      13,
      -111,
      -17,
      -89,
      -73,
      111,
      -96,
      87,
      -4,
      63,
      -5,
      43,
      -18,
      -15,
      114,
      -7,
      114,
      86,
      -60,
      17,
      100,
      -121,
      38,
      117,
      14,
      31,
      -41,
      99,
      71,
      71,
      -33,
      -96,
      105,
      -96,
      111,
      86,
      19,
      26,
      -11,
      -71,
      -32,
      -116,
      62,
      80,
      86,
      107,
      34,
      -98,
      46,
      -96,
      86,
      27,
      -28,
      -90,
      -117,
      124,
      64,
      -17,
      18,
      -7,
      2,
      3,
      1,
      0,
      1
    )

    val encrypted = encrypt("Anmol".encodeToByteArray(), publicKey.toPublicKey(), Padding.OAEP, OAEPParameterSpec())
    assertNotNull(encrypted)
  }

  @Test
  fun `when user and channel keypair is created then we encr and decr works!`() {
    with(CapillaryInstances.getInstance("anmol", isTest = true)) {
      val publicKeyUser = publicKey()
      assertNotNull(publicKeyUser)
      val privateKeyUser = privateKey()
      assertNotNull(privateKeyUser)
      val encrypted = encrypt("Anmol".encodeToByteArray(), publicKeyUser)
      val decrypted = decrypt(encrypted, privateKeyUser)
      assertTrue(decrypted.contentEquals("Anmol".encodeToByteArray()))

      with(CapillaryInstances.getInstance("channel", isTest = true)) {
        val publicKeyChannel = publicKey()
        val privateKeyChannel = privateKey()

        val encryptedChannelPrivateKey = encrypt(privateKeyChannel.encoded, publicKeyUser)
        val encryptedChannelMessage = encrypt("Anmol".encodeToByteArray(), publicKeyChannel)
        val decryptedPrivateKey = decrypt(encryptedChannelPrivateKey, privateKeyUser)
        assertNotNull(decryptedPrivateKey)
        assertNotNull(encryptedChannelMessage)
        val decryptedChannelMessageUsingChannelPrivateKey =
          decrypt(encryptedChannelMessage, this.privateKeyFromBytes(decryptedPrivateKey))
        assertNotNull(decryptedChannelMessageUsingChannelPrivateKey)
        assertTrue(decryptedChannelMessageUsingChannelPrivateKey.contentEquals("Anmol".encodeToByteArray()))
      }
    }


  }
}